r, c, t = gets.split.map(&:to_i)

# Mapをセットする
rows = []
r.times do |t1|
  rows << gets.chomp.split("").map()
end

# 全てのルートを5x + 3的に変換し、配列に格納


def convertRoutes

  return #
end

def getMaximumTime(max = 1)

  if inspectRoute(max) >=  # maxの場合の最長ルート時間と、指定された制限時間の比較
    return max
  else
    judgeOverflow(max += 1)
  end
end

puts judgeOverflow

# (全ルートを調べる) until 最大値を発見　⇛　再帰？
# いや、毎回全ルートを調べる必要はない。
# 黒マスの時間は未知とは言えど、最も時間がかかるルートは１度で割り出せる。
# 仮に黒マスの時間を2と置けば、白マスの1と差がでる。これで割り出せそう。
# 割り出したルートはメモしておこう。[1, x, x, 1, 1]こんな感じ？
# いや、(10 + 5x)的に表現できそう。
# このxの部分に黒マスの時間が来るから、インクリメントしてループさせながら最大値を割り出せばいいのか。
# かかる時間をyとしたら、ひょっとしてy = 5x + 10的な１時関数になる？？？
# えっ、じゃあ答え出すの超カンタンじゃない？再帰すらいらない？そんなことある？
# ああ、でも、ルート割り出しが容易じゃないや。2x + 1 と x + 4なら、どちらが長くかかるかは、x依存だ。
# でも、逆に言えば、ルートの割り出しさえできればxのインクリメントループは不要？
# いや、ルートを割り出すためにxをインクリメントさせるんだ。
# それでも、全ルートを 4x + 4的に変換して配列化しておくことは可能だ。
# その配列に対して、インクリメントしたxを全適用して、最大値を求めよう。そして、その最大値が指定時間を超える直前の時間が答えか。
# ということは分かったけど、肝心の全ルート探索の方法が分からない。
